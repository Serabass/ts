# 5. Promise и магия `async`/`await`

Помните времена, когда асинхронные функции вызывались вот таким образом?

```typescript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt', function (err, data) {
        if (err) throw err;
        fs.writeFile('file.txt', '', function (err) {
            if (err) throw err;
            
            cb();
        });
    });
}
```

Этому явлению придумали устрашающее название `Callback Hell`.

В текущем случае это не так страшно, т.к. здесь последовательно вызываются всего две асинхронные функции. Но что если нам необходимо последовательно вызвать десять, двадцать, 100500 асинхронных функций? Тогда наш код может превратится в лестницу, сопоставимую с лестницей на Медео. Такой код - это ничто иное, как проявление жестокости по отношению к программистам.

Поэтому и были введены Промисы.

Технология сама по себе не нова: Промисы уже давно есть в Ruby, C# (там это называется Task) и, как я полагаю, много где ещё.

Теперь вышепредставленный код мы можем описать таким образом (с учётом того, что наша библиотека `fs` умеет работать с Промисами):

```javascript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt').then(function (data) {
        fs.writeFile('file.txt', '').then(function () {

        });
    });
}
```

Не сильно помогло, да? Согласен. Однако здесь стоит отметить, что теперь мы имеем дело с объектом, которым намного удобнее манипулировать. Ну и наряду с появлением Промисов был введён стандарт `async`/`await` (который также перекочевал в JS из Ruby и C#).

Поэтому теперь мы можем делать вот так:

```typescript

async function myAsyncAwaitFunction(): Promise<void> {
    let data = await fs.readFile('file.txt');
    await fs.writeFile('file.txt', '');
}

```

Объект Promise по умолчанию содержит всего два метода: `.then()` и `.catch()`.

Метод `.then()` принимает функцию, которая выполнится по возвращении ответа.
Метод `.catch()` принимает функцию, которая выполнится при выбросе ошибки во время выполнения асинхронной операции.

Стоит отметить, что обе функции всегда возвращают только один аргумент, либо пустоту. Нельзя вернуть более одного аргумента, как это было в случае устаревших `(err, arg1, arg2, arg3, argN) => `. Тогда это было допустимо.

Небольшая вкусняшка: когда мы используем подход `async` / `await`, для отлова ошибок мы можем использовать привычный `try`/`catch`:

```typescript
async function myAsyncAwaitFunction(): Promise<void> {
    try {
        let data = await fs.readFile('file.txt');
        await fs.writeFile('file.txt', '');
    } catch (err) {
        // ...
    }
}
```

Если хотите сохранить свой спокойный сон, не пытайтесь смотреть на то, что из этого получается на выходе после компиляции (Я предупреждал).
