# Promise и магия `async`/`await`

Помните времена, когда асинхронные функции вызывались вот таким образом?

```typescript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt', function (err, data) {
        if (err) throw err;
        fs.writeFile('file.txt', '', function (err) {
            if (err) throw err;
            
            cb();
        });
    });
}
```

Этому явлению придумали устрашающее название `Callback Hell`.

В текущем случае это не так страшно, т.к. здесь последовательно вызываются всего две асинхронные функции. Но что если нам необходимо последовательно вызвать десять, двадцать, 100500 асинхронных функций? Тогда наш код может превратится в лестницу, сопоставимую с лестницей на Медео. Такой код - это ничто иное, как проявление жестокости по отношению к программистам.

Поэтому и были введены Промисы.

Технология сама по себе не нова: Промисы уже давно есть в Ruby, C# (там это называется Task) и, как я полагаю, много где ещё.

Теперь вышепредставленный код мы можем описать таким образом (с учётом того, что наша библиотека `fs` умеет работать с Промисами):

```javascript
function callbackHellExample(cb: Function) {
    fs.readFile('file.txt').then(function (data) {
        fs.writeFile('file.txt', '').then(function () {

        });
    });
}
```

Не сильно помогло, да? Согласен. Однако здесь стоит отметить, что теперь мы имеем дело с объектом, которым намного удобнее манипулировать. Ну и наряду с появлением Промисов был введён стандарт `async`/`await` (который также пришёл из Ruby и C#).

Поэтому теперь мы можем делать вот так:

```typescript

async function myAsyncAwaitFunction(): Promise<void> {
    let data = await fs.readFile('file.txt');
    await fs.writeFile('file.txt', '');
}

```
